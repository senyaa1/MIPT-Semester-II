# Лабораторная работа по оптимизации хеш-таблицы

## Оптимизации

### Использование типа `__m256`.
Поскольку максимальная длина слова в английском переводе "Война и мир" не превышает $32$ символа (т.е. $256$ бит), то мы можем хранить слова в SIMD типе `__m256`, что сильно ускорит время работы.

#### Новая `strcmp`
Для работы с такими строками реализуем свою версию `strcmp` для `__mm256`. Просто используем встроенную инструкцию побайтового сравнения. Здесь решил использовать inline-assembly, ведь тут очень короткая функция.
```c
unsigned int mask;
__asm__ volatile("vpcmpeqb %[b], %[a], %%ymm0\n\t"
		 "vpmovmskb %%ymm0, %[mask]\n\t"
		 : [mask] "=r"(mask)
		 : [a] "x"(a), [b] "x"(b)
		 : "ymm0");

return unlikely(mask == 0xFFFFFFFFu);
```

#### Поиск ключа
Используем интринзики, чтобы подгрузить строчку в ymm-регистр для дальнейшего использования.
```c
__m256i get_ymm_key(char *key, size_t len)
{
	__attribute__((aligned(32))) char aligned_buf[AVX_WORD_SZ] = {};
	memcpy(aligned_buf, key, len % AVX_WORD_SZ);				// компилятор видит, что длина строки меньше 32 -- будет использовать AVX2 инструкции.

	__m256i key_ymm = _mm256_load_si256((__m256i const *)aligned_buf);
	return key_ymm;
}
```

### CRC32
В X86 процессорах с набором инструкций SSE4.2 и выше существует инструкция `crc32`, которая вычисляет данный хеш намного быстрее, чем обычная реализация на C. 
Переделаем нашу реализацию `crc32`, чтобы она использовала одноимённую инструкцию. Не забываем, что слова помещаются в ymm-регистр. 
```asm
hash_crc32:
	push    rbp
	mov     rbp, rsp
	sub     rsp, 32

	vmovdqu ymm0, [rsp]

	mov     rax, 0FFFFFFFFh

	lea     rsi, [rsp]
	crc32   rax, qword [rsi]        ; bytes  0– 7
	crc32   rax, qword [rsi +  8]   ; bytes  8–15
	crc32   rax, qword [rsi + 16]   ; bytes 16–23
	crc32   rax, qword [rsi + 24]   ; bytes 24–31

	not     eax

	leave
	ret
```

### Остальное

#### Branch hints

#### Prefetch

## Результаты
Результаты тестов, после $30$ итераций.

 - Оптимизированная хеш-таблица (среднее ± σ):  $491.4 ± 0.9$ ms
 - Наивная реализация (среднее ± σ):    $1.199 ± 0.110$ s
 
Оптимизированная версия получилась в $2.44 ± 0.22$ раза быстрее чем исходная реализация.
